// server.js
const express = require('express');
const axios = require('axios');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');
require('dotenv').config();
const nodemailer = require('nodemailer');

const app = express();
const port = process.env.SERVERPORT || 5000;
console.log('Server port:', port);

// Middleware
app.use(cors({
    origin: '*', // Allow all origins
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true
}));
app.use(express.json());

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});

const MAX_TOKENS = 600;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
const DATA_FILE = path.join(__dirname, 'data.json');
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
const GOOGLE_CSE_ID = process.env.GOOGLE_CSE_ID;

// Create a transporter object using easyname.com SMTP
const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: process.env.EMAIL_PORT, // Standard SMTP port with TLS
    secure: process.env.EMAIL_SECURE, // true for 465, false for other ports
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD
    },
    tls: {
        // Do not fail on invalid certs
        rejectUnauthorized: false
    }
});

// Function to generate email HTML content
function generateEmailContent(product, recommendation, searchResults) {
    console.log('Generating email content with:', {
        product,
        recommendationLength: recommendation.length,
        searchResultsCount: searchResults ? searchResults.length : 0,
        searchResults: searchResults
    });

    // Convert markdown to HTML
    const recommendationHtml = recommendation
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold text
        .replace(/\n/g, '<br>') // Line breaks
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold text again for nested cases
        .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic text
        .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" style="color: #2563eb;">$1</a>'); // Links

    const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h1 style="color: #2563eb;">Review Cruncher Report</h1>
            <h2 style="color: #1e293b;">${product}</h2>
            <div style="margin: 20px 0; padding: 20px; background: #f8fafc; border-radius: 8px;">
                ${recommendationHtml}
            </div>
            <p style="color: #64748b; font-size: 14px; margin-top: 30px;">
                This email was generated by Review Cruncher. For more information, visit our website.
            </p>
        </div>
    `;

    console.log('Generated email content length:', emailContent.length);
    return emailContent;
}

// Function to read the data file
async function readDataFile() {
    try {
        const data = await fs.readFile(DATA_FILE, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        // If file doesn't exist or is empty, return default structure
        return { reviews: [] };
    }
}

// Function to write to the data file
async function writeDataFile(data) {
    await fs.writeFile(DATA_FILE, JSON.stringify(data, null, 2), 'utf8');
}

// Endpoint to handle product recommendations
app.post('/api/recommend', async (req, res) => {
    try {
        const { product, email } = req.body;

        if (!product || !email) {
            return res.status(400).json({ error: 'Product and email are required' });
        }

        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
        };

        const params = {
            model: 'gpt-4.1',
            max_tokens: MAX_TOKENS,
            messages: [
                {
                    role: 'developer',
                    content: `You are a product recommendation expert. When the user tells you a product, identify the best-in-class alternative and return a comprehensive comparison and recommendation. If the user does not input a specific product (but a product group or category), identify the best-in-class product in that category and return a recommendation for that product. Provide a clear and structured comparison with the following format:

**[Product Name] vs. [Best-in-Class Alternative]**

**Key Features Comparison:**
- [Product Name]:
  * [Key Feature 1]
  * [Key Feature 2]
  * [Key Feature 3]
- [Best-in-Class Alternative]:
  * [Key Feature 1]
  * [Key Feature 2]
  * [Key Feature 3]

**Advantages [Product Name]:**
1. [First advantage]
2. [Second advantage]
3. [Third advantage]

**Advantages [Best-in-Class Alternative]:**
1. [First advantage]
2. [Second advantage]
3. [Third advantage]

**Price Comparison:**
[Product Name] is around [price] and [Best-in-Class Alternative] is around [price].

**Value for Money Rating (1-5):**
- [Product Name]: [Rating] - [Brief explanation]
- [Best-in-Class Alternative]: [Rating] - [Brief explanation]

**Recommendation:**
Make a clear recommendation to buy or not, considering the user's needs and the comparison above.

Use markdown formatting with **bold** text for headers and ensure proper line breaks and 1 empty line between sections. Limit the answer to 600 tokens, but make sure to give a complete answer.`
                },
                {
                    role: 'user',
                    content: `Hello. Shall I buy ${product}?`
                }
            ]
        };

        const response = await axios.post(OPENAI_API_URL, params, { headers });
        const firstChoice = response.data.choices[0];
        const responseData = {
            responseMessage: firstChoice.message.content,
            reason: firstChoice.finish_reason
        };

        // Save the request and response to data.json
        const data = await readDataFile();
        data.reviews.push({
            timestamp: new Date().toISOString(),
            product,
            email,
            response: responseData
        });
        await writeDataFile(data);

        res.json({ response: responseData });
    } catch (error) {
        console.error('Error:', error.response?.data || error.message);
        
        // Handle specific error cases
        if (error.response?.status === 401) {
            return res.status(401).json({ error: 'API key is invalid' });
        } else if (error.response?.status === 429) {
            return res.status(429).json({ error: 'Rate limit exceeded' });
        }
        
        res.status(500).json({ error: 'Something went wrong with the request' });
    }
});

// Google Search endpoint
app.post('/api/search', async (req, res) => {
    try {
        const { query } = req.body;
        if (!query) {
            return res.status(400).json({ error: 'Query is required' });
        }
        const url = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(query)}&key=${GOOGLE_API_KEY}&cx=${GOOGLE_CSE_ID}`;
        const response = await axios.get(url);

        // You can customize what you return to the frontend
        // Here, we return the top 5 results with title, link, and snippet
        const results = (response.data.items || []).slice(0, 5).map(item => ({
            title: item.title,
            link: item.link,
            snippet: item.snippet
        }));

        res.json({ results });
    } catch (error) {
        console.error('Google Search Error:', error.response?.data || error.message);
        res.status(500).json({ error: 'Google Search failed' });
    }
});

// Combined endpoint for both recommendation and search
app.post('/api/combined', async (req, res) => {
    try {
        const { product, email } = req.body;

        if (!product || !email) {
            return res.status(400).json({ error: 'Product and email are required' });
        }

        // Make both API calls in parallel
        const [recommendationResponse, searchResponse] = await Promise.all([
            // Recommendation API call
            axios.post(OPENAI_API_URL, {
                model: 'gpt-4.1',
                max_tokens: MAX_TOKENS,
                messages: [
                    {
                        role: 'developer',
                        content: `You are a product recommendation expert. When the user tells you a product, identify the best-in-class alternative and return a comprehensive comparison and recommendation. If the user does not input a specific product (but a product group or category), identify the best-in-class product in that category and return a recommendation for that product. Provide a clear and structured comparison with the following format:

**[Product Name] vs. [Best-in-Class Alternative]**

**Key Features Comparison:**
- [Product Name]:
  * [Key Feature 1]
  * [Key Feature 2]
  * [Key Feature 3]
- [Best-in-Class Alternative]:
  * [Key Feature 1]
  * [Key Feature 2]
  * [Key Feature 3]

**Advantages [Product Name]:**
1. [First advantage]
2. [Second advantage]
3. [Third advantage]

**Advantages [Best-in-Class Alternative]:**
1. [First advantage]
2. [Second advantage]
3. [Third advantage]

**Price Comparison:**
[Product Name] is around [price] and [Best-in-Class Alternative] is around [price].

**Value for Money Rating (1-5):**
- [Product Name]: [Rating] - [Brief explanation]
- [Best-in-Class Alternative]: [Rating] - [Brief explanation]

**Recommendation:**
Make a clear recommendation to buy or not. Decide for one of the products and give a clear recommendation.

Use markdown formatting with **bold** text for headers and ensure proper line breaks and 1 empty line between sections. Limit the answer to 500 tokens, but make sure to give a complete answer.`
                    },
                    {
                        role: 'user',
                        content: `Hello. Shall I buy ${product}?`
                    }
                ]
            }, {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENAI_API_KEY}`
                }
            }),
            // Google Search API call
            axios.get(`https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(`${product} Youtube review`)}&key=${GOOGLE_API_KEY}&cx=${GOOGLE_CSE_ID}`)
        ]);

        const recommendationData = {
            responseMessage: recommendationResponse.data.choices[0].message.content + '\n\n\n**Youtube reviews**\n\n' + 
                (searchResponse.data.items || [])
                    .slice(0, 5)
                    .map((item, index) => `${index + 1}. [${item.title}](${item.link})`)
                    .join('\n'),
            reason: recommendationResponse.data.choices[0].finish_reason
        };

        const searchResults = (searchResponse.data.items || []).slice(0, 5).map(item => ({
            title: item.title,
            link: item.link,
            snippet: item.snippet
        }));

        // Save both results to data.json
        const data = await readDataFile();
        data.reviews.push({
            timestamp: new Date().toISOString(),
            product,
            email,
            recommendation: recommendationData,
            searchResults
        });
        await writeDataFile(data);

        res.json({
            recommendation: recommendationData,
            search: searchResults
        });
    } catch (error) {
        console.error('Error:', error.response?.data || error.message);
        
        if (error.response?.status === 401) {
            return res.status(401).json({ error: 'API key is invalid' });
        } else if (error.response?.status === 429) {
            return res.status(429).json({ error: 'Rate limit exceeded' });
        }
        
        res.status(500).json({ error: 'Something went wrong with the request' });
    }
});

// Endpoint to send email
app.post('/api/send-email', async (req, res) => {
    try {
        console.log('Raw request body:', req.body);
        
        const { product, email, recommendation, search_results } = req.body;

        console.log('Parsed request data:', {
            product,
            email,
            recommendationLength: recommendation ? recommendation.length : 0,
            searchResultsCount: search_results ? search_results.length : 0,
            searchResults: search_results
        });

        if (!product || !email || !recommendation) {
            console.error('Missing required fields:', { product, email, recommendation: !!recommendation });
            return res.status(400).json({ error: 'Missing required fields' });
        }

        const mailOptions = {
            from: process.env.EMAIL_USER,
            to: email,
            subject: `Review Cruncher Report: ${product}`,
            html: generateEmailContent(product, recommendation, search_results || [])
        };

        console.log('Sending email with options:', {
            from: mailOptions.from,
            to: mailOptions.to,
            subject: mailOptions.subject,
            searchResultsCount: search_results ? search_results.length : 0
        });

        const info = await transporter.sendMail(mailOptions);
        console.log('Email sent successfully:', info.messageId);
        
        res.json({ success: true, message: 'Email sent successfully' });
    } catch (error) {
        console.error('Email error:', error);
        res.status(500).json({ error: 'Failed to send email' });
    }
});

// Endpoint to get recent reviews
app.get('/api/recent-reviews', async (req, res) => {
    try {
        const data = await readDataFile();
        // Sort by timestamp descending and get last 4
        const sorted = (data.reviews || []).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        const last4 = sorted.slice(0, 4);
        res.json({ reviews: last4 });
    } catch (error) {
        console.error('Error fetching recent reviews:', error);
        res.status(500).json({ error: 'Failed to fetch recent reviews' });
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});
